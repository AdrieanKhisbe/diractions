#compdef _diraction-dispatch
# completion for the dispatcher command

#  words: 1:function 2:directory 3:pattern



if (( CURRENT == 3));
then # Subcomand completion
    case $words[3] in
	/*) # Pattern :D
	    local diract=$words[2]
	    local dirdir=`eval echo $diract` # §TODO: now, move up!!
	    local pattern="${words[3]#/}"
	    local cmd="$cd $dirdir && ls -d $pattern* 2>/dev/null  | sed -E 's:^:/:g' | xargs echo"
	    # maybe extract fund

	    for dir in $(eval $cmd)
	    do
		compadd $dir
	    done && return 0
	    ;;
	*)	# Basic argument
	    local -a subcommands
	    subcommands=(
		'ls:List files in the specified folder (alias l)'
		'exec:Exec (through eval) the specified command (alias e - , _ )'
		'interactive:Go in interactive mode, to perform several commands (alias i,prompt,shell)'
		'/:Go in some of the subfolder if provided (alias c cd)'
		'edit:Edit the given subfile (alias ed)'
		'browser:Launch browser on the directory (alias b)'
		'tree:Launch tree command (alias t)'
	    )
	    #TODO: maybe make this a gloabl variable to add user defined function?
	    # or extend the array here?

	    _describe -t commands "Dispatcher subcommand" subcommands
	    return
    esac
else # argument completion
    # completion won't be called without a 2 arg, so sure will be 4+
    case $words[3] in
	# no args
	e|"exec") # maybe files?
	    return 0
	    ;;
	i|interactive|prompt|shell|help) return 0;;
	#§todo: search how to add message

	*)
	    local compfun="_${words[3]}"
	    if functions "$compfun" > /dev/null; then
		# §TODO: should shift word so that it works.
		# §TODO: how to improve context, change PWD?
		# if so do it up
		$compfun && return 0
		# beware to file completion
	    else
		# decide what to do. "no completion, you are on your own"
	    fi
	    ;;
    esac

fi
